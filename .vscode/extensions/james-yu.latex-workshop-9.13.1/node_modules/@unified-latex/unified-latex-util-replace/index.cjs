"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var unified_latex_util_replace_exports = {};
__export(unified_latex_util_replace_exports, {
  firstSignificantNode: () => firstSignificantNode,
  firstSignificantNodeIndex: () => firstSignificantNodeIndex,
  lastSignificantNode: () => lastSignificantNode,
  lastSignificantNodeIndex: () => lastSignificantNodeIndex,
  replaceNode: () => replaceNode,
  replaceNodeDuringVisit: () => replaceNodeDuringVisit,
  replaceStreamingCommand: () => replaceStreamingCommand,
  replaceStreamingCommandInGroup: () => replaceStreamingCommandInGroup,
  unifiedLatexReplaceStreamingCommands: () => unifiedLatexReplaceStreamingCommands
});
module.exports = __toCommonJS(unified_latex_util_replace_exports);

// ../unified-latex-util-print-raw/dist/index.js
var linebreak = Symbol("linebreak");
var ESCAPE = "\\";
function _printRaw(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw(node.content);
    case "argument":
      return [node.openMark, ..._printRaw(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw(node.content),
          suffix
        ];
      }
      return [linebreak, "%", ..._printRaw(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw(node.env);
      var envStart = [ESCAPE + "begin{", ...env, "}"];
      var envEnd = [ESCAPE + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
    case "group":
      return ["{", ..._printRaw(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw(node.args);
      escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
      return [escape, ..._printRaw(node.content), ...argsString];
    case "parbreak":
      return [linebreak, linebreak];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE,
        node.env,
        node.escape,
        ..._printRaw(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak ? "\n" : x).join("");
}

// ../unified-latex-util-match/dist/index.js
function createMacroMatcher(macros) {
  const macrosHash = Array.isArray(macros) ? macros.length > 0 ? typeof macros[0] === "string" ? Object.fromEntries(
    macros.map((macro2) => {
      if (typeof macro2 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2, {}];
    })
  ) : Object.fromEntries(
    macros.map((macro2) => {
      if (typeof macro2 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2.escapeToken != null) {
        return [
          macro2.content,
          { escapeToken: macro2.escapeToken }
        ];
      }
      return [macro2.content, {}];
    })
  ) : {} : macros;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher(macros) {
  const environmentsHash = Array.isArray(macros) ? Object.fromEntries(
    macros.map((str) => {
      return [str, {}];
    })
  ) : macros;
  return function matchAgainstEnvironments(node) {
    if (!match.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw(node.env) === envName);
  },
  anyEnvironment(node) {
    return match.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher,
  createEnvironmentMatcher
};
var {
  anyEnvironment,
  anyMacro,
  anyString,
  argument,
  blankArgument,
  comment,
  environment,
  group,
  macro,
  math,
  parbreak,
  string,
  whitespace
} = match;

// ../unified-latex-util-visit/dist/index.js
function listMathChildren(node) {
  const NULL_RETURN = { enter: [], leave: [] };
  if (Array.isArray(node)) {
    return NULL_RETURN;
  }
  if (match.math(node)) {
    return { enter: ["content"], leave: [] };
  }
  const renderInfo = node._renderInfo || {};
  if (renderInfo.inMathMode == null) {
    return NULL_RETURN;
  }
  if (match.macro(node)) {
    if (renderInfo.inMathMode === true) {
      return { enter: ["args"], leave: [] };
    } else if (renderInfo.inMathMode === false) {
      return { enter: [], leave: ["args"] };
    }
  }
  if (match.environment(node)) {
    if (renderInfo.inMathMode === true) {
      return { enter: ["content"], leave: [] };
    } else {
      return { enter: [], leave: ["content"] };
    }
  }
  return NULL_RETURN;
}
var CONTINUE = Symbol("continue");
var SKIP = Symbol("skip");
var EXIT = Symbol("exit");
var DEFAULT_CONTEXT = {
  inMathMode: false,
  hasMathModeAncestor: false
};
function visit(tree, visitor, options) {
  const {
    startingContext = DEFAULT_CONTEXT,
    test = () => true,
    includeArrays = false
  } = options || {};
  let enter;
  let leave;
  if (typeof visitor === "function") {
    enter = visitor;
  } else if (visitor && typeof visitor === "object") {
    enter = visitor.enter;
    leave = visitor.leave;
  }
  walk(tree, {
    key: void 0,
    index: void 0,
    parents: [],
    containingArray: void 0,
    context: { ...startingContext }
  });
  function walk(node, { key, index, parents, context, containingArray }) {
    const nodePassesTest = includeArrays ? test(node, { key, index, parents, context, containingArray }) : !Array.isArray(node) && test(node, { key, index, parents, context, containingArray });
    const result = enter && nodePassesTest ? toResult(
      enter(node, {
        key,
        index,
        parents,
        context,
        containingArray
      })
    ) : [CONTINUE];
    if (result[0] === EXIT) {
      return result;
    }
    if (result[0] === SKIP) {
      return leave && nodePassesTest ? toResult(
        leave(node, {
          key,
          index,
          parents,
          context,
          containingArray
        })
      ) : result;
    }
    if (Array.isArray(node)) {
      for (let index2 = 0; index2 > -1 && index2 < node.length; index2++) {
        const item = node[index2];
        const result2 = walk(item, {
          key,
          index: index2,
          parents,
          context,
          containingArray: node
        });
        if (result2[0] === EXIT) {
          return result2;
        }
        if (typeof result2[1] === "number") {
          index2 = result2[1] - 1;
        }
      }
    } else {
      let childProps = ["content", "args"];
      switch (node.type) {
        case "macro":
          childProps = ["args"];
          break;
        case "comment":
        case "string":
        case "verb":
        case "verbatim":
          childProps = [];
          break;
        default:
          break;
      }
      const mathModeProps = listMathChildren(node);
      for (const key2 of childProps) {
        const value = node[key2];
        const grandparents = [node].concat(parents);
        if (value == null) {
          continue;
        }
        const newContext = { ...context };
        if (mathModeProps.enter.includes(key2)) {
          newContext.inMathMode = true;
          newContext.hasMathModeAncestor = true;
        } else if (mathModeProps.leave.includes(key2)) {
          newContext.inMathMode = false;
        }
        const result2 = walk(value, {
          key: key2,
          index: void 0,
          parents: grandparents,
          context: newContext,
          containingArray: void 0
        });
        if (result2[0] === EXIT) {
          return result2;
        }
      }
    }
    return leave && nodePassesTest ? toResult(
      leave(node, {
        key,
        index,
        parents,
        context,
        containingArray
      })
    ) : result;
  }
}
function toResult(value) {
  if (value == null) {
    return [CONTINUE];
  }
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}

// libs/replace-node.ts
function replaceNode(ast, visitor) {
  visit(ast, {
    leave: (node, info) => {
      let replacement = visitor(node, info);
      if (typeof replacement === "undefined" || replacement === node) {
        return;
      }
      if (!info.containingArray || info.index == null) {
        throw new Error(
          "Trying to replace node, but cannot find containing array"
        );
      }
      if (replacement === null || Array.isArray(replacement) && replacement.length === 0) {
        info.containingArray.splice(info.index, 1);
        return info.index;
      }
      if (!Array.isArray(replacement)) {
        replacement = [replacement];
      }
      info.containingArray.splice(info.index, 1, ...replacement);
      return info.index + replacement.length;
    }
  });
}

// ../unified-latex-util-trim/dist/index.js
function trim(nodes) {
  if (!Array.isArray(nodes)) {
    console.warn("Trying to trim a non-array ast", nodes);
    return nodes;
  }
  const { trimmedStart } = trimStart(nodes);
  const { trimmedEnd } = trimEnd(nodes);
  return { trimmedStart, trimmedEnd };
}
function trimStart(nodes) {
  const { start } = amountOfLeadingAndTrailingWhitespace(nodes);
  nodes.splice(0, start);
  for (const leadingToken of nodes) {
    if (!match.comment(leadingToken)) {
      break;
    }
    if (leadingToken.leadingWhitespace || leadingToken.sameline) {
      leadingToken.leadingWhitespace = false;
      delete leadingToken.position;
    }
    if (start > 0 && leadingToken.sameline) {
      leadingToken.sameline = false;
      delete leadingToken.position;
    }
  }
  return { trimmedStart: start };
}
function trimEnd(nodes) {
  const { end } = amountOfLeadingAndTrailingWhitespace(nodes);
  nodes.splice(nodes.length - end, end);
  for (let i = nodes.length - 1; i >= 0; i--) {
    const trailingToken = nodes[i];
    if (!match.comment(trailingToken)) {
      break;
    }
    delete trailingToken.suffixParbreak;
    if (match.comment(trailingToken) && trailingToken.leadingWhitespace && !trailingToken.sameline) {
      trailingToken.leadingWhitespace = false;
      delete trailingToken.position;
    }
  }
  return { trimmedEnd: end };
}
function amountOfLeadingAndTrailingWhitespace(ast) {
  let start = 0;
  let end = 0;
  for (const node of ast) {
    if (match.whitespace(node) || match.parbreak(node)) {
      start++;
    } else {
      break;
    }
  }
  if (start === ast.length) {
    return { start, end: 0 };
  }
  for (let i = ast.length - 1; i >= 0; i--) {
    const node = ast[i];
    if (match.whitespace(node) || match.parbreak(node)) {
      end++;
    } else {
      break;
    }
  }
  return { start, end };
}

// ../unified-latex-util-split/dist/index.js
function splitOnCondition(nodes, splitFunc = () => false, options) {
  if (!Array.isArray(nodes)) {
    throw new Error(`Can only split an Array, not ${nodes}`);
  }
  const { onlySplitOnFirstOccurrence = false } = options || {};
  const splitIndices = [];
  for (let i = 0; i < nodes.length; i++) {
    if (splitFunc(nodes[i])) {
      splitIndices.push(i);
      if (onlySplitOnFirstOccurrence) {
        break;
      }
    }
  }
  if (splitIndices.length === 0) {
    return { segments: [nodes], separators: [] };
  }
  let separators = splitIndices.map((i) => nodes[i]);
  let segments = splitIndices.map((splitEnd, i) => {
    const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;
    return nodes.slice(splitStart, splitEnd);
  });
  segments.push(
    nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length)
  );
  return { segments, separators };
}
function unsplitOnMacro({
  segments,
  macros
}) {
  if (segments.length === 0) {
    console.warn("Trying to join zero segments");
    return [];
  }
  if (segments.length !== macros.length + 1) {
    console.warn(
      "Mismatch between lengths of macros and segments when trying to unsplit"
    );
  }
  let ret = segments[0];
  for (let i = 0; i < macros.length; i++) {
    ret = ret.concat(macros[i]).concat(segments[i + 1]);
  }
  return ret;
}

// libs/utils/significant-node.ts
function firstSignificantNode(nodes, parbreaksAreInsignificant) {
  const index = firstSignificantNodeIndex(nodes, parbreaksAreInsignificant);
  if (index == null) {
    return null;
  }
  return nodes[index];
}
function lastSignificantNode(nodes, parbreaksAreInsignificant) {
  const index = lastSignificantNodeIndex(nodes, parbreaksAreInsignificant);
  if (index == null) {
    return null;
  }
  return nodes[index];
}
function lastSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
  for (let i = nodes.length - 1; i >= 0; i--) {
    const node = nodes[i];
    if (match.whitespace(node) || match.comment(node) || parbreaksAreInsignificant && match.parbreak(node)) {
      continue;
    }
    return i;
  }
  return void 0;
}
function firstSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (match.whitespace(node) || match.comment(node) || parbreaksAreInsignificant && match.parbreak(node)) {
      continue;
    }
    return i;
  }
  return void 0;
}

// libs/utils/join-without-excess-whitespace.ts
function isSpaceLike(node) {
  return match.whitespace(node) || match.comment(node) && Boolean(node.leadingWhitespace);
}
function joinWithoutExcessWhitespace(head, tail) {
  if (tail.length === 0) {
    return;
  }
  if (head.length === 0) {
    head.push(...tail);
    return;
  }
  const headEnd = head[head.length - 1];
  const tailStart = tail[0];
  if (match.whitespace(headEnd) && match.whitespace(tailStart)) {
    head.push(...tail.slice(1));
    return;
  }
  if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {
    if (match.whitespace(headEnd) && match.comment(tailStart)) {
      const comment3 = {
        type: "comment",
        content: tailStart.content,
        sameline: true,
        leadingWhitespace: true
      };
      tail = tail.slice(1);
      trimStart(tail);
      head.pop();
      head.push(comment3, ...tail);
      return;
    }
    head.push(...tail);
    return;
  }
  if (match.comment(headEnd) && match.comment(tailStart)) {
    if (tailStart.leadingWhitespace || tailStart.sameline) {
      head.push(
        { type: "comment", content: tailStart.content },
        ...tail.slice(1)
      );
      return;
    }
    head.push(...tail);
    return;
  }
  let comment2 = match.comment(headEnd) ? headEnd : tailStart;
  if (!match.comment(comment2)) {
    throw new Error(
      `Expected a comment but found ${JSON.stringify(comment2)}`
    );
  }
  if (!comment2.leadingWhitespace || !comment2.sameline) {
    comment2 = {
      type: "comment",
      content: comment2.content,
      leadingWhitespace: true,
      sameline: true
    };
  }
  head.pop();
  head.push(comment2, ...tail.slice(1));
}

// libs/utils/wrap-significant-content.ts
function wrapSignificantContent(content, wrapper) {
  let hoistUntil = 0;
  let hoistAfter = content.length;
  for (let i = 0; i < content.length; i++) {
    if (match.whitespace(content[i]) || match.comment(content[i])) {
      hoistUntil = i + 1;
      continue;
    }
    break;
  }
  for (let j = content.length - 1; j >= 0; j--) {
    if (match.whitespace(content[j]) || match.comment(content[j])) {
      hoistAfter = j;
      continue;
    }
    break;
  }
  if (hoistUntil === 0 && hoistAfter === content.length) {
    return ensureArray(wrapper(content));
  }
  const frontMatter = content.slice(0, hoistUntil);
  const middle = content.slice(hoistUntil, hoistAfter);
  const backMatter = content.slice(hoistAfter, content.length);
  return frontMatter.concat(wrapper(middle), backMatter);
}
function ensureArray(x) {
  if (!Array.isArray(x)) {
    return [x];
  }
  return x;
}

// libs/utils/replace-streaming-command-in-array.ts
function replaceStreamingCommandInArray(nodes, isStreamingCommand, replacer) {
  while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {
    nodes.pop();
    trimEnd(nodes);
  }
  const foundStreamingCommands = [];
  for (let i = nodes.length - 1; i >= 0; i--) {
    const node = nodes[i];
    if (isStreamingCommand(node)) {
      const wrapper = (content) => replacer(content, node);
      let tail = nodes.slice(i + 1);
      trimStart(tail);
      tail = wrapSignificantContent(tail, wrapper);
      foundStreamingCommands.push(node);
      nodes.splice(i);
      joinWithoutExcessWhitespace(nodes, tail);
    }
  }
  return { foundStreamingCommands };
}

// libs/replace-streaming-command.ts
function replaceStreamingCommandInGroup(group2, isStreamingCommand, replacer, options) {
  const content = group2.content;
  let popFromGroup = isStreamingCommand(firstSignificantNode(content));
  let innerProcessed = replaceStreamingCommand(
    content,
    isStreamingCommand,
    replacer,
    options
  );
  if (innerProcessed.length === 0) {
    return [];
  }
  if (popFromGroup) {
    return innerProcessed;
  } else {
    return [{ type: "group", content: innerProcessed }];
  }
}
function replaceStreamingCommand(ast, isStreamingCommand, replacer, options) {
  if (typeof isStreamingCommand !== "function") {
    throw new Error(
      `'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`
    );
  }
  const {
    macrosThatBreakPars = [
      "part",
      "chapter",
      "section",
      "subsection",
      "subsubsection",
      "vspace",
      "smallskip",
      "medskip",
      "bigskip",
      "hfill"
    ],
    environmentsThatDontBreakPars = []
  } = options || {};
  let processedContent = [];
  if (match.group(ast)) {
    processedContent = replaceStreamingCommandInGroup(
      ast,
      isStreamingCommand,
      replacer
    );
  }
  if (Array.isArray(ast)) {
    const nodes = ast;
    let scanIndex = nodes.length;
    let sliceIndex = scanIndex;
    while (scanIndex > 0 && (isStreamingCommand(nodes[scanIndex - 1]) || match.whitespace(nodes[scanIndex - 1]))) {
      scanIndex--;
      if (isStreamingCommand(nodes[scanIndex])) {
        sliceIndex = scanIndex;
      }
    }
    if (sliceIndex !== nodes.length) {
      nodes.splice(sliceIndex);
    }
    const macroThatBreaks = match.createMacroMatcher(macrosThatBreakPars);
    const envThatDoesntBreak = match.createEnvironmentMatcher(
      environmentsThatDontBreakPars
    );
    const isPar = (node) => match.parbreak(node) || match.macro(node, "par") || macroThatBreaks(node) || match.environment(node) && !envThatDoesntBreak(node) || node.type === "displaymath";
    const splitByPar = splitOnCondition(nodes, isPar);
    splitByPar.separators = splitByPar.separators.map(
      (sep) => match.macro(sep, "par") ? { type: "parbreak" } : sep
    );
    const replacers = [];
    let segments = splitByPar.segments.map((segment) => {
      if (segment.length === 0) {
        return segment;
      }
      function applyAccumulatedReplacers(nodes2) {
        if (replacers.length === 0) {
          return nodes2;
        }
        return wrapSignificantContent(
          nodes2,
          composeReplacers(replacers)
        );
      }
      const { foundStreamingCommands } = replaceStreamingCommandInArray(
        segment,
        isStreamingCommand,
        replacer
      );
      const ret = applyAccumulatedReplacers(segment);
      foundStreamingCommands.forEach((macro2) => {
        replacers.push((nodes2) => {
          const ret2 = replacer(nodes2, macro2);
          if (!Array.isArray(ret2)) {
            return [ret2];
          }
          return ret2;
        });
      });
      return ret;
    });
    if (segments.length > 1) {
      segments.forEach((segment, i) => {
        if (i === 0) {
          trimEnd(segment);
        } else if (i === segments.length - 1) {
          trimStart(segment);
        } else {
          trim(segment);
        }
      });
    }
    processedContent = unsplitOnMacro({
      segments,
      macros: splitByPar.separators
    });
  }
  return processedContent;
}
function composeReplacers(replacers) {
  if (replacers.length === 0) {
    throw new Error("Cannot compose zero replacement functions");
  }
  return (nodes) => {
    let ret = nodes;
    for (let i = 0; i < replacers.length; i++) {
      const func = replacers[i];
      ret = func(ret);
    }
    return ret;
  };
}

// libs/replace-node-during-visit.ts
function replaceNodeDuringVisit(replacement, info) {
  const parent = info.parents[0];
  if (!parent) {
    throw new Error(`Cannot replace node: parent not found`);
  }
  const container = parent[info.key];
  if (!Array.isArray(container)) {
    throw new Error(`Cannot replace node: containing array not found`);
  }
  if (info.index == null) {
    throw new Error(`Cannot replace node: node index undefined`);
  }
  if (!Array.isArray(replacement)) {
    container[info.index] = replacement;
  } else {
    container.splice(info.index, 1, ...replacement);
  }
}

// libs/unified-latex-streaming-command.ts
var unifiedLatexReplaceStreamingCommands = function unifiedLatexReplaceStreamingCommands2(options) {
  const { replacers = {} } = options || {};
  const isReplaceable = match.createMacroMatcher(replacers);
  return (tree) => {
    visit(
      tree,
      (group2, info) => {
        if (info.context.hasMathModeAncestor || !group2.content.some(isReplaceable)) {
          return;
        }
        let fixed = replaceStreamingCommand(
          group2,
          isReplaceable,
          (content, command) => {
            return replacers[command.content](content, command);
          }
        );
        if (!info.containingArray || info.index == null) {
          return;
        }
        const prevToken = info.containingArray[info.index - 1];
        const nextToken = info.containingArray[info.index + 1];
        if (match.whitespaceLike(prevToken) && match.whitespaceLike(fixed[0])) {
          trimStart(fixed);
        }
        if (match.whitespaceLike(nextToken) && match.whitespaceLike(fixed[fixed.length - 1])) {
          trimEnd(fixed);
        }
        replaceNodeDuringVisit(fixed, info);
      },
      { test: match.group }
    );
    visit(
      tree,
      (nodes, info) => {
        if (info.context.hasMathModeAncestor || !nodes.some(isReplaceable)) {
          return;
        }
        const replaced = replaceStreamingCommand(
          nodes,
          isReplaceable,
          (content, command) => {
            return replacers[command.content](content, command);
          }
        );
        if (replaced !== nodes) {
          nodes.length = 0;
          nodes.push(...replaced);
        }
      },
      { includeArrays: true, test: Array.isArray }
    );
  };
};
//# sourceMappingURL=index.cjs.map
