"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var unified_latex_util_split_exports = {};
__export(unified_latex_util_split_exports, {
  arrayJoin: () => arrayJoin,
  splitOnCondition: () => splitOnCondition,
  splitOnMacro: () => splitOnMacro,
  unsplitOnMacro: () => unsplitOnMacro
});
module.exports = __toCommonJS(unified_latex_util_split_exports);

// ../unified-latex-util-print-raw/dist/index.js
var linebreak = Symbol("linebreak");
var ESCAPE = "\\";
function _printRaw(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw(node.content);
    case "argument":
      return [node.openMark, ..._printRaw(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw(node.content),
          suffix
        ];
      }
      return [linebreak, "%", ..._printRaw(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw(node.env);
      var envStart = [ESCAPE + "begin{", ...env, "}"];
      var envEnd = [ESCAPE + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
    case "group":
      return ["{", ..._printRaw(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw(node.args);
      escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
      return [escape, ..._printRaw(node.content), ...argsString];
    case "parbreak":
      return [linebreak, linebreak];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE,
        node.env,
        node.escape,
        ..._printRaw(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak ? "\n" : x).join("");
}

// ../unified-latex-util-match/dist/index.js
function createMacroMatcher(macros) {
  const macrosHash = Array.isArray(macros) ? macros.length > 0 ? typeof macros[0] === "string" ? Object.fromEntries(
    macros.map((macro2) => {
      if (typeof macro2 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2, {}];
    })
  ) : Object.fromEntries(
    macros.map((macro2) => {
      if (typeof macro2 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2.escapeToken != null) {
        return [
          macro2.content,
          { escapeToken: macro2.escapeToken }
        ];
      }
      return [macro2.content, {}];
    })
  ) : {} : macros;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher(macros) {
  const environmentsHash = Array.isArray(macros) ? Object.fromEntries(
    macros.map((str) => {
      return [str, {}];
    })
  ) : macros;
  return function matchAgainstEnvironments(node) {
    if (!match.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw(node.env) === envName);
  },
  anyEnvironment(node) {
    return match.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher,
  createEnvironmentMatcher
};
var {
  anyEnvironment,
  anyMacro,
  anyString,
  argument,
  blankArgument,
  comment,
  environment,
  group,
  macro,
  math,
  parbreak,
  string,
  whitespace
} = match;

// libs/split-on-condition.ts
function splitOnCondition(nodes, splitFunc = () => false, options) {
  if (!Array.isArray(nodes)) {
    throw new Error(`Can only split an Array, not ${nodes}`);
  }
  const { onlySplitOnFirstOccurrence = false } = options || {};
  const splitIndices = [];
  for (let i = 0; i < nodes.length; i++) {
    if (splitFunc(nodes[i])) {
      splitIndices.push(i);
      if (onlySplitOnFirstOccurrence) {
        break;
      }
    }
  }
  if (splitIndices.length === 0) {
    return { segments: [nodes], separators: [] };
  }
  let separators = splitIndices.map((i) => nodes[i]);
  let segments = splitIndices.map((splitEnd, i) => {
    const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;
    return nodes.slice(splitStart, splitEnd);
  });
  segments.push(
    nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length)
  );
  return { segments, separators };
}

// libs/split-on-macro.ts
function splitOnMacro(ast, macroName) {
  if (typeof macroName === "string") {
    macroName = [macroName];
  }
  if (!Array.isArray(macroName)) {
    throw new Error("Type coercion failed");
  }
  const isSeparator = match.createMacroMatcher(macroName);
  const { segments, separators } = splitOnCondition(ast, isSeparator);
  return { segments, macros: separators };
}

// libs/unsplit-on-macro.ts
function unsplitOnMacro({
  segments,
  macros
}) {
  if (segments.length === 0) {
    console.warn("Trying to join zero segments");
    return [];
  }
  if (segments.length !== macros.length + 1) {
    console.warn(
      "Mismatch between lengths of macros and segments when trying to unsplit"
    );
  }
  let ret = segments[0];
  for (let i = 0; i < macros.length; i++) {
    ret = ret.concat(macros[i]).concat(segments[i + 1]);
  }
  return ret;
}

// libs/array-join.ts
function arrayJoin(array, sep) {
  return array.flatMap((item, i) => {
    if (i === 0) {
      return item;
    }
    if (Array.isArray(sep)) {
      return [...sep, ...item];
    } else {
      return [sep, ...item];
    }
  });
}
//# sourceMappingURL=index.cjs.map
